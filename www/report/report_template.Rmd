---
title: 'Climate Resilience Metric Report'
params:
  poly: NULL #The region of interest for the report. NEEDED
  data2: NULL #The other data to plot (ecoregion, etc)
  table: TRUE #Include the table of metrics?
  l1data: TRUE #Include L1 eco data in that table
  l2data: TRUE #Include L2 eco data in that table
  l3data: TRUE #Include L3 eco data in that table
  fwvel: TRUE #Include the fw velocity map and text in this report?
  bwvel: TRUE #Include the bw velocity map and text in this report?
  topodiv: TRUE #Include the topographic diversity map and text in this report?
  biovel: TRUE #Include the biotic velocity maps and text in this report?
  climconn: TRUE #Include the climate connectivity maps and text in this report?
  carbon: TRUE #Include the carbon content maps and text in this report?
  intact: TRUE #Include the intactness map and text in this report?
  starplot: TRUE #Include a starplot of the metrics in this report?
  scatterplot: TRUE #Include a scatterplot grid of the metrics in this report?
  printCode: FALSE  #Print the code too or just the output? 
  html: FALSE #Interactive HTML? The report is generated differently, NEEDED
  RBS: TRUE # Report progress? I put to true as we want the user to see progress
  fmt: "" #The report format
  pa: FALSE #Let me know if we are generating a report for a PA or not.
  appURL: ""
always_allow_html: true 
header-includes:
output:
  pdf_document: 
    toc: true
    fig_caption: false
    keep_tex: false
    latex_engine: pdflatex
    template: "./template.tex"
    fig_width: 6.5
    fig_height: 6.5
  word_document: 
    reference_docx: "./template.docx"
  html_document:
    theme: readable
    toc: true
    df_print: paged
    fig.height: 8
    fig.width: 8 
urlcolor: blue
sansfont: roboto
mainfont: roboto
---

```{r SETUP, include=FALSE}
# set this option in the first code chunk in the document
if(isFALSE(params$html)){
  knitr::opts_chunk$set(echo = params$printCode,message = FALSE, warning = FALSE,
                     error = F,tidy = T, out.width="100%",dpi=600,
                      fig.align = "center", strip.white = T,cache = F)
} else if(params$fmt=="word_document"){
  knitr::opts_chunk$set(echo = params$printCode,message = FALSE, warning = FALSE,
                     error = F,tidy = T,fig.height="5.5",fig.width="5.5",dpi=600,
                     strip.white = T,cache = F)
} else {
  knitr::opts_chunk$set(echo = params$printCode,message = FALSE, warning = FALSE,
                     error = F,tidy = T, out.width="100%",
                      fig.align = "center", strip.white = T,cache = F)
}

LeafletSideBySidePlugin <- htmlDependency("leaflet-side-by-side","2.0.0",
                                          src = c("../shared/leaflet-side-by-side-gh-pages"),
                                          script = "leaflet-side-by-side.js")
registerPlugin <- function(mapFunction, plugin) {
  mapFunction$dependencies <- c(mapFunction$dependencies, list(plugin))
  mapFunction
}
if(!dir.exists("tmp")){dir.create("tmp")}
if(!dir.exists("imgs")){dir.create("imgs")}
if(!dir.exists("interactive_reports")){dir.create("interactive_reports")}
if(!dir.exists("static_reports")){dir.create("static_reports")}
bds <- st_bbox(params$poly)
bds <- unname(bds)
fullmap<-mapFunction()
halfmap<-mapFunction(width="50%")
fullhalfmap<-mapFunction(height="400px")
cols<-colorNumeric(
  palette="RdYlBu",
  domain=c(0,100),
  reverse=F
)
polydata <-params$poly %>%st_drop_geometry() %>% select(Name,intact,elevdiv,fwvelref,bwvelref,brdref,treref,treec,soilc) 

if(isTRUE(params$html)) {
  chunktype = "hold"
} else {
  chunktype = "asis"
}
if(isTRUE(params$RBS)){
  shiny::setProgress(0.04)
}
```

## Climate Resilience Metric Report for `r params$poly$Name`

This report contains the data tables and figures for `r paste(params$poly$Name)`. The report has been generated by the AdaptWest Climate Resilience
web-application at <center><h4>
[https://adaptwest.databasin.org/pages/climate-resilience-data-explorer](https://adaptwest.databasin.org/pages/climate-resilience-data-explorer)
</h4></center>
Additional features and capabilities may be developed and the format of this 
report and the application layout may change in the future.

#### App development was supported by AdaptWest (with support from the Wilburforce Foundation) and the Canadian Forest Service of Natural Resources Canada.

## Introduction
Conservation planners and practitioners increasingly wonder how they should revise conservation strategies in the face of the unprecedented threat to biodiversity from climate change. One key step is to consider the relatively consistent spatial patterns that characterize the "geography of climate exposure and resilience". These patterns are often generated by the interaction of global climate systems with regional topography, but may also be influenced by biogeographic processes and other factors. A qualitative understanding of these patterns can help planners craft conservation strategies that are more resilient to uncertainty regarding the future intensity of climate change.

The ultimate goal of landscape-level conservation planning under climate change is to facilitate persistence of species and ecosystem processes by increasing the adaptive capacity of landscapes and regions. The **ESAC** framework, developed by the IPCC [(McCarthy et al. 2001)](https://www.ipcc.ch/ipccreports/tar/wg2/pdf/wg2TARfrontmatter.pdf), proposes that climate **exposure** and **sensitivity** interact and are mediated by **adaptive capacity**, resulting in the degree of vulnerability of the system to climate change.

The complexity and uncertainty inherent in projecting future climates has created barriers to consideration of climate change in conservation planning. However, an increasing volume of freely accessible information, applied within **communities of practice** that bring together researchers and practitioners, promises to lower barriers to integrating climate resilience within regional planning processes. 

Most of the data considered here are measures of climate **exposure**. Data, such as the location of climate refugia for individual species, which incorporates information on a species' climatic tolerances or niche, also addresses climate **sensitivity**. The ultimate goal of providing such information to planners is to support conservation management that, by protecting key areas identified by the data, increases the **adaptive capacity** of the landscape and its ability to support native species and ecosystems into the future.

A diversity of conservation strategies is needed to address climate change adaptation challenges. Among the most important are identification and protection of climate refugia (areas buffered from climate change where organisms can persist) and climate corridors (areas that play a key role in facilitating
dispersal under climate change). The threat to biodiversity from climate change strengthens the rationale for networks of large protected areas that represent all landscape types and species, protect intact environmental gradients, and maintain ecological and evolutionary processes.

Conservation practitioners can use the data presented in this report to help inform management strategies in particular watersheds and management areas. This information can also provide context as to how threats and opportunities in their region compare with those in other areas.

Cite this app and report as: 
<blockquote>Beckers J, Carroll C. 2020. AdaptWest climate resilience data explorer. doi: [doi](http://dx.doi.org/[doi]).</blockquote>

For further information and citation refer to: 
<blockquote>Carroll C, Noss RF. 2020. Rewilding in the face of climate change. Conservation Biology (Early View). doi: [10.1111/cobi.13531](http://dx.doi.org/10.1111/cobi.13531).</blockquote>

```{r, results = 'asis', echo = F}
if (params$RBS){
  shiny::setProgress(0.11)
}
```

In this report, we present data for `r paste(params$park)` on key metrics that can be used to assess landscape-level climate resilience and vulnerability. Spatial data shown in this report are freely available at the links below.

  **Climate Resilience Metric:**
  
  * [Forward and backward climatic velocity](https://adaptwest.databasin.org/pages/adaptwest-velocitywna)
  * [Topodiversity](https://adaptwest.databasin.org/pages/environmental-diversity-north-america)
  * [Biotic velocity](https://adaptwest.databasin.org/pages/climatic-macrorefugia-for-trees-and-songbirds)
  * [Climate connectivity](https://adaptwest.databasin.org/pages/climate-connectivity-north-america)
  * [Aboveground forest carbon](http://globbiomass.org/wp-content/uploads/GB_Maps/Globbiomass_global_dataset.html)
  * [Soil carbon](https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/c02ddf8b-cbfb-4533-a9c3-7bf0790fd042)
  * [Intactness (the inverse of landuse intensity)](https://figshare.com/articles/Global_Human_Modification/7283087)

## Basic Information for `r params$poly$Name`

```{r REFUGIA_TABLE, echo = params$printCode, results = 'asis',eval = params$table}
if(isTRUE(params$l1data)) {
  l1data<-ecol1stats[which(ecol1stats$Name==params$poly$ecoreg1),]
  l1name<-eco1namekey[which(eco1namekey$ECO1VALUE ==params$poly$ecoreg1),2]
  # l1data[,1]<-as.character(l1data[,1])
  l1data[1,1]<-"L1 Ecoregion"
  # names(l1data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l1data,use.names=F)
  row.names(polydata)[nrow(polydata)] <- paste0(row.names(polydata)[nrow(polydata)], 
                                footnote_marker_alphabet(nrow(polydata)))
}

if(isTRUE(params$l2data)) {
  l2data<-ecol2stats[which(ecol2stats$Name==params$poly$ecoreg2),]
  l2name<-eco2namekey[which(eco2namekey$ECO2VALUE==params$poly$ecoreg2),2]
  # l2data[[namecol]]<-as.character(l2data[,1])
  l2data[1,1]<-"L2 EcoRegion"
  # names(l2data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l2data,use.names=F)
  row.names(polydata)[nrow(polydata)] <- paste0(row.names(polydata)[nrow(polydata)], 
                                footnote_marker_alphabet(nrow(polydata)))
}


if(isTRUE(params$l3data)) {
  l3data<-ecol3stats[which(ecol3stats$Name==params$poly$ecoreg3),]
  l3name<-eco3namekey[which(eco3namekey$ECO3VALUE==params$poly$ecoreg3),2]
  # l3data[,1]<-as.character(l3data[,1])
  l3data[1,1]<-"L3 EcoRegion"
  # names(l3data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l3data,use.names=F)
  row.names(polydata)[nrow(polydata)] <- paste0(row.names(polydata)[nrow(polydata)], 
                                footnote_marker_alphabet(nrow(polydata)))
}

names(polydata)<-names(metriclist)[c(9,1:8)]
names(polydata)[3]<-"Topographic Diversity"
polydata<-setDF(polydata)

if(params$fmt %in% c("word_document")){
  outtable <- flextable::flextable(data = polydata)
  outtable <- flextable::align(x=outtable, align = "center", part = "header")
  outtable <- flextable::colformat_num(x=outtable,j=c(3,4,8,9),digits=2)
  outtable <- flextable::colformat_num(x=outtable,j=c(2,5:7),digits=3)
  outtable <- flextable::set_caption(x=outtable, paste0("Adaptation Metrics for: ", params$poly$Name))
  outtable <- flextable::theme_booktabs(x=outtable)
  outtable <- flextable::width(x=outtable,j=1,width = 1.0)
  outtable <- flextable::width(x=outtable,j=2,width = 0.73)
  outtable <- flextable::width(x=outtable,j=3,width = 0.88)
  outtable <- flextable::width(x=outtable,j=4,width = 0.69)
  outtable <- flextable::width(x=outtable,j=5,width = 0.75)
  outtable <- flextable::width(x=outtable,j=6:9,width = 0.61)
  outtable <- flextable::font(x=outtable,fontname="Calibri",part="all")
  outtable <- flextable::fontsize(x=outtable,size=10,part="all")
  outtable <- flextable::footnote(
    x=outtable,i=2:4,j=1,
    value=as_paragraph(
      c(paste0("L1 ecoregion: ",l1name),
        paste0("L2 ecoregion: ",l2name),
        paste0("L3 ecoregion: ",l3name)
      )),
    ref_symbols=c("a","b","c"),
    part = "body"
  )
 
  
  
} else if (params$fmt == "pdf_document"){
  outtable<-knitr::kable(booktabs = T,format="latex",
    x=polydata,
    digits=3,
    row.names=F,
    align = c("l",rep('c', 8)),
    caption = paste0("Adaptation Metrics for: ", params$poly$Name)) %>%
    kableExtra::column_spec(column=1,width="1in") %>%
    kableExtra::column_spec(column=2,width="0.73in") %>%
    kableExtra::column_spec(column=3,width="0.88in") %>%
    kableExtra::column_spec(column=4,width="0.69in") %>%
    kableExtra::column_spec(column=5,width="0.75in") %>%
    kableExtra::column_spec(column=6:9,width="0.61in") %>%
    kableExtra::footnote(
      alphabet = c(
        paste0("L1 ecoregion: ",l1name),
        paste0("L2 ecoregion: ",l2name),
        paste0("L3 ecoregion: ",l3name)
        ),
      footnote_as_chunk = T
      ) %>%
    kableExtra::kable_styling(latex_options=c("HOLD_position","scale_down"))
} else {
  outtable<-knitr::kable(booktabs = T, format="html",
    x=polydata,
    digits=3,
    row.names=F,
    align = c("l",rep('c', 8)),
    caption = paste0("Adaptation Metrics for: ", params$poly$Name)) %>%
    kableExtra::column_spec(column=2:9,width_max = "12em") %>%
    kableExtra::column_spec(column=1,width_max = "40em") %>%
    kableExtra::footnote(
      alphabet = c(
        paste0("L1 ecoregion: ",l1name),
        paste0("L2 ecoregion: ",l2name),
        paste0("L3 ecoregion: ",l3name)
        ),
      footnote_as_chunk = T
      ) %>%
    kableExtra::kable_styling(bootstrap_options = c("hover","condensed"))
}
outtable
if (params$RBS){
  shiny::setProgress(0.15)
}
```


```{r, results = 'asis', echo = F}
# if (params$fmt == "word_document") {
#   cat('#####')
# }
if (params$RBS){
  shiny::setProgress(0.23)
}
```
```{r,echo=F}
if(params$fmt=="word_document"){
  ow = "13.2cm"
} else if (params$html){
  ow = "100%"
} else{
  ow = "80%"
}
```

## Map of forward-velocity-based climate refugia for `r params$poly$Name`
```{r fwdvel, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'center',eval=!is.na(params$poly$fwvelref)}
ind<-which(tilelist$tileName=="fwvel500")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"),dpi=600)
  } else if(!file.exists(paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/fwsvel_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/fwsvel_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"),dpi=600)
  } else {
    m <- fullmap %>%
      clearGroup("metrics") %>%
      addPolygons(
        data = params$poly,
        fillColor = NULL,
        fillOpacity = 0.00,
        weight = 5,
        color = "black",
        stroke = T,
        label= htmlEscape(paste0('Name: ',params$poly$Name))
      ) %>%
      addTiles(
        urlTemplate = tilelist$tileSubdir[ind],
        attribution = tilelist$tileAttribution[ind],
        group = "Forward Climate Refugia",
        options = tileOptions(
          tms = T,
          minZoom = minZoom,
          maxZoom = maxZoom,
          unloadInvisibleTiles = T,
          noWrap = T,
          opacity = 0.9,
          zIndex = 9000
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal=cols,
        values=c(0:100),
        title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
        opacity = 0.9,
        labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
      ) %>%
      addLayersControl(
        position = c("topleft"),
        baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
        overlayGroups = c("Place labels","Forward Climate Refugia"),
        options = layersControlOptions(collapsed = T, autoZIndex = F)
      ) %>%
      fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
      mapview::mapshot(
        x= m,
        url = paste0(getwd(),"/tmp/fwsvel_",params$poly$Name,".html"),
        file=paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"),
        remove_url=F,
        selfcontained=T
      )
    knitr::include_graphics(paste0(getwd(),"/imgs/fwsvel_",params$poly$Name,".png"),dpi=600)
  }
} else {
  m <- fullmap %>%
    clearGroup("metrics") %>%
    addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>%
    addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Forward Climate Refugia",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Forward Climate Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.28)
}
```

**Climate velocity** is the speed that an organism needs to travel to keep pace with climate. Climate refugia (areas of species persistence during climate change) are areas of low enough velocity that the organism can remain within their suitable climate.

To calculate analog-based climatic velocity, climate is categorized into types, and the straight-line distance is measured between a site and the nearest site with the same climate type in a different time period. Climatic velocity is influenced by processes 
at several scales: 

* Local topography 
* Regional topographic position 
* Location on continent
* Location in relationship to global climate circulation patterns

**Forward climatic velocity** measures the straight-line distance between a site's current climate type and the nearest site with the same climate type under future climates. This represents the rate at which an organism currently at a location must move to find future suitable climate. Forward velocity, which provides information on the ability of resident species and ecosystems to persist regionally, will often be high in alpine areas because reaching the nearest analogous future climate may require dispersal to distant mountaintops. A refugia metric, in which higher values represent areas with greater resilience to climate change, is derived by applying log transformation to velocity values and inverting the result, so that highest velocity areas have the lowest refugia score. 

**How to interpret the map:** The map above shows refugia based on forward climatic velocity from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5). Red shades indicate areas with highest refugia value (i.e., lowest velocity and climate exposure), whereas blue shades indicate areas with highest velocity and most climate exposure. The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/adaptwest-velocitywna). **All maps shown in this report, data were rescaled to 100 equal-area quantiles in order to increase comparability between metrics. Because this scaling was based on the range of values across North America, colors may be relatively uniform at the extent of an individual management area or watershed.**

```{r, results = 'asis', echo = F}
if (params$RBS){
  shiny::setProgress(0.34)
}
```

## Map of backward-velocity-based climate refugia for `r params$poly$Name`
```{r bwdvel, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'center',eval=!is.na(params$poly$bwvelref)}
ind<-which(tilelist$tileName=="bwvel500")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"))
  } else if(!file.exists(paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/bwsvel_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/bwsvel_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% 
    addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% 
    addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Backward Climate Refugia",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Backward Climate Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/bwsvel_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/bwsvel_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Backward Climate Refugia",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal=cols,
    values=c(0:100),
    title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
    opacity = 0.9,
    labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
    position = c("topleft"),
    baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
    overlayGroups = c("Place labels","Backward Climate Refugia"),
    options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.36)
}
```

**Backward climatic velocity** measures the straight-line distance between a site's future climate type and the nearest site with the same climate type under current climates. Backward velocity represents the distance and rate at which organisms adapted to a location's future climate will need to move to reach that location, and reflects a location's ability to serve as a refugium for species and ecosystems. 
Backward velocity is generally low in alpine areas, because adapted organisms can reach the site from nearby downslope locations. Values are often high in valley bottom habitat because organisms must travel longer distances to colonize these locally new habitat conditions.

Areas with low backward climatic velocity will have higher values as refugia, so we transform velocity values to a refugia index by multiplying the log transformation of velocity by negative 1. A log transformation is used because we are most interested in variation in the index at relatively low velocity values. 

**How to interpret the map:** The map above shows refugia based on backward climatic velocity from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5). Red shades indicate areas with highest refugia value (i.e., lowest velocity and climate exposure), whereas blue shades indicate areas with highest velocity and climate exposure. The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/adaptwest-velocitywna).

```{r, results = 'asis', echo = F}
if (params$RBS){
  shiny::setProgress(0.40)
}
```

## Map of microrefugia potential for `r params$poly$Name`
```{r Topodiversity, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'center',eval=!is.na(params$poly$elevdiv)}
ind<-which(tilelist$tileName=="elevdiv500")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"))
  } else if(!file.exists(paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/elevdiv_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/elevdiv_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Topographic Diversity",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Topographic Diversity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/elevdiv_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/elevdiv_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Topographic Diversity",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal=cols,
    values=c(0:100),
    title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
    opacity = 0.9,
    labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Topographic Diversity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.45)
}
```

**Microrefugia potential**
 - Many approaches to identifying areas that will be refuges for biodiversity under climate change are based on predicting future climate. Other approaches use only information on the current environment, that is data on how species distributions, communities, ecosystems, and broader patterns of biodiversity are influenced by abiotic drivers such as soils, geology, and topography.
Refugia also span a range of spatial scales. Coarse-resolution metrics such as climatic velocity which identify **macrorefugia** (areas where broad-scale climate is relatively stable and suitable for persistence) can be complemented with other information that helps identify fine-scale **microrefugia** (small areas with locally favorable environments within otherwise unsuitable climates).  
Micro-scale climate refugia can be created by terrain-related factors. Topographic diversity (topodiversity) data are useful for identifying areas where a heterogeneous physical environment (e.g., steep elevation gradients or diverse aspects) increases the likelihood that species will be able to find nearby suitable habitat as climate changes.  
Microrefugia occur both within and outside of macro-refugia (areas of lowest climate velocity).    

**How to interpret the map:** The map above shows topographic diversity. Red shades indicate areas with highest topodiversity and microrefugia potential, whereas blue shades indicate areas with lowest topodiversity and microrefugia potential. The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/environmental-diversity-north-america). 

```{r, results = 'asis', echo = F}
# if (params$fmt == "word_document") {
#   cat('#####')
# }
if (params$RBS){
  shiny::setProgress(0.49)
}
```

```{r,echo=F}
if(params$fmt=="word_document"){
  ow = "8.2cm"
} else if (params$html){
  ow = "100%"
} else{
  ow = "50%"
}
```

```{r, results="asis",eval=!is.na(params$poly$brdref)}
cat("## ",paste0("Map of biotic-velocity-based refugia for ", params$poly$Name))
```

```{r biotic_velocity, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'default',eval=!is.na(params$poly$brdref)}
ind<-which(tilelist$tileName=="birdref500")
ind2<-which(tilelist$tileName=="treeref500")

if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treeref_",params$poly$Name,".png")))
  } else if(!file.exists(paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/birdref_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/birdref_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0(getwd(),"/tmp/treeref_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/treeref_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treeref_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Bird Refugia",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Bird Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/birdref_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "Tree Refugia",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind2]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Tree Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/treeref_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/treeref_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/birdref_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treeref_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Bird Refugia",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Bird Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "Tree Refugia",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind2]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Tree Refugia"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.53)
}
```

`r if(!is.na(params$poly$brdref)){"**Biotic velocity** is a metric that combines data from climate projections with data on the distributions of individual species. Climatic niche models based on correlations between species distributions and current climatic conditions are then projected forward to predict distribution under future climates. Biotic velocity represents the distance between a site and the nearest site projected to be climatically suitable for the species under future projected climates."}`

`r if(!is.na(params$poly$brdref)){"Biotic velocity provides a lower estimate of migration requirements than does climatic velocity because the metric assumes local populations can adapt to any climatic conditions found within the full range of the species current distribution. The metric can be reported as a species-specific refugia index or averaged across a taxonomic group."}`
`r if(!is.na(params$poly$brdref)){"When compared to refugia defined by low climatic velocity, biotic velocity highlights the influence of biogeographic factors (including past refugia locations) which have made certain regions more biodiverse than expected based on climate alone."}`
`r if(!is.na(params$poly$brdref)){"Biotic-velocity-based refugia vary depending on the species considered. The metrics shown here, from [Stralberg et al. 2018,](https://onlinelibrary.wiley.com/doi/abs/10.1111/geb.12731) combine data on refugia for 268 songbird and 324 tree species in the US and Canada."}`

`r if(!is.na(params$poly$brdref)){"**How to interpret the map:** The map above shows refugia based on climatic niche models for songbirds"}``r if(!is.na(params$poly$brdref)){ifelse(params$html,"(top panel)","(left panel)")}``r if(!is.na(params$poly$brdref)){", and trees "}``r if(!is.na(params$poly$brdref)){ifelse(params$html,"(bottom panel).","(right panel).")}``r if(!is.na(params$poly$brdref)){"Red shades indicate areas with highest refugia value, whereas blue shades indicate areas with lowest refugia value (i.e., highest biotic velocity). The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/climatic-macrorefugia-for-trees-and-songbirds). Data are currently limited to Canada and the US. We hope to add data for Mexico in the future."}`

```{r, results = 'asis', echo = F}
if (params$fmt == "word_document") {
  cat('#####')
}
if (params$RBS){
  shiny::setProgress(0.60)
}
```

## Map of climate connectivity for `r params$poly$Name`
```{r climate_connectivity, echo = params$printCode, results = chunktype, out.width = ow,fig.align = 'default',eval=T}
ind<-which(tilelist$tileName=="fwshpath")
ind2<-which(tilelist$tileName=="bwshpath")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"),paste0(getwd(),"/imgs/bwshpath_",params$poly$Name,".png")))
  } else if(!file.exists(paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/fwshpath_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/fwshpath_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0(getwd(),"/tmp/bwshpath_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/bwshpath_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"),paste0(getwd(),"/imgs/bwshpath_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Forward Climate Connectivity",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      colors=c(rgb(255,0,0,maxColorValue = 255),
               rgb(255,127,127,maxColorValue = 255),
               rgb(225,225,225,maxColorValue = 255)),
      values=c(150,450,750),
      labels=c("High","Medium","Low"),
      title = paste0("Legend <br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      className= "info legend Legend"
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Forward Climate Connectivity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/fwshpath_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "Backward Climate Connectivity",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>% 
    addLegend(
      position = "bottomright",
      colors=c(rgb(0,112,255,maxColorValue = 255),
               rgb(190,232,255,maxColorValue = 255),
               rgb(225,225,225,maxColorValue = 255)),
      values=c(150,450,750),
      labels=c("High","Medium","Low"),
      title = paste0("Legend <br>",tilelist$tileGroup[ind2]),
      opacity = 0.9,
      className= "info legend Legend"
    ) %>% 
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Backward Climate Connectivity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/bwshpath_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/bwshpath_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/fwshpath_",params$poly$Name,".png"),paste0(getwd(),"/imgs/bwshpath_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Forward Climate Connectivity",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    colors=c(rgb(0,112,255,maxColorValue = 255),
               rgb(190,232,255,maxColorValue = 255),
               rgb(225,225,225,maxColorValue = 255)),
    values=c(150,450,750),
    labels=c("High","Medium","Low"),
    title = paste0("Legend <br>",tilelist$tileGroup[ind]),
    opacity = 0.9,
    className= "info legend Legend"
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Forward Climate Connectivity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "Backward Climate Connectivity",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    colors=c(rgb(0,112,255,maxColorValue = 255),
               rgb(190,232,255,maxColorValue = 255),
               rgb(225,225,225,maxColorValue = 255)),
    values=c(150,450,750),
    labels=c("High","Medium","Low"),
    title = paste0("Legend <br>",tilelist$tileGroup[ind2]),
    opacity = 0.9,
    className= "info legend Legend"
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Backward Climate Connectivity"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.62)
}
```

**Climate connectivity** - The persistence of many species under climate change will depend on areas that facilitate dispersal to newly climatically suitable habitat. **Climate connectivity areas** or "climate corridors" are areas that form the best route between current climate types and where those climates will occur in the future under climate change. Climate connectivity areas are distinct from refugia and thus poorly captured by many existing conservation strategies. Because dispersing organisms may need to avoid hostile climates, these routes are often circuitous rather than the straight-line paths, as is assumed when measuring standard climatic velocity [(Dobrowski and Parks 2016)](https://www.nature.com/articles/ncomms12349). Several methods exist for identifying climate corridors. [Carroll et al. 2018](https://onlinelibrary.wiley.com/doi/full/10.1111/gcb.14373) used centrality metrics to identify areas where many potential dispersal paths overlap.
Broad-scale topography and climate influence connectivity paths. Routes were found to be funneled along north-south trending passes and valley systems and along the leeward or drier slopes of north-south trending mountain ranges. Climate connectivity paths also tend to avoid areas of novel and disappearing climates. Human landuses were not considered in the results shown here, but may further constrain the ability of species to disperse through these areas. Results from a subsequent study which considered both climate and landuse may be accessed [here](https://adaptwest.databasin.org/pages/landuse-and-climate-connectivity).

**How to interpret the map:** The maps above shows forward `r ifelse(params$html,"(top panel)","(left panel)")` and backward `r ifelse(params$html,"(bottom panel)","(right panel)")` climatic connectivity areas from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5). Note that the color scheme differs from that used in previous maps, with red showing forward-velocity-based connectivity areas and blue showing backward-velocity-based connectivity areas. These connectivity areas hold a high concentration of dispersal paths between current and future climate analogs. Due to computational limitations, these areas were mapped at 5 km resolution, which may cause corridors to appear angular on finer-resolution maps. The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/climate-connectivity-north-america).

```{r, results = 'asis', echo = F}
if (params$fmt == "word_document") {
  cat('#####')
}
if (params$RBS){
  shiny::setProgress(0.68)
}
```

## Map of below- and above-ground carbon for `r params$poly$Name`
```{r carbon, echo = params$printCode, results = chunktype,out.width = ow, fig.align = 'default',eval=!is.na(params$poly$soilc)}
ind<-which(tilelist$tileName=="soilc500")
ind2<-which(tilelist$tileName=="treena500")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treec_",params$poly$Name,".png")))
  } else if(!file.exists(paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/soilc_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/soilc_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0(getwd(),"/tmp/treec_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/treec_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treec_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Soil Carbon Content",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
      addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Soil Carbon Content"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/soilc_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "Tree Carbon Content",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
      addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind2]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Tree Carbon Content"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/treec_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/treec_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0(getwd(),"/imgs/soilc_",params$poly$Name,".png"),paste0(getwd(),"/imgs/treec_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Soil Carbon Content",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal=cols,
    values=c(0:100),
    title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
    opacity = 0.9,
    labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Soil Carbon Content"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal=cols,
    values=c(0:100),
    title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind2]),
    opacity = 0.9,
    labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
    position = c("topleft"),
    baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
    overlayGroups = c("Place labels","Tree Carbon Content"),
    options = layersControlOptions(collapsed = T, autoZIndex = F)
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.7)
}
```

**Below- and above-ground carbon** - Climate adaptation planning addresses the impacts of climate change via efforts to increase landscape resilience and other strategies. However, it is important to place climate adaptation strategies within a larger context which includes mitigation strategies to address the causes of climate change by reducing accumulation of greenhouse gases in the atmosphere. An example of such a dual adaptation/mitigation strategy is a recent conservation proposal termed the Global Deal for Nature, which proposes that protected area networks be expanded to include areas that hold large reserves of **aboveground (biomass) and belowground (soil and biomass) carbon**, with the aim of reducing disturbances that accelerate release of stored carbon ([Dinerstein et al. 2019](http://doi.org/10.1126/sciadv.aaw2869)). In North America, soil carbon is generally at highest levels in large boreal peatlands, implying that protection of large boreal landscapes is critical for conserving areas of high soil carbon. Patterns of above-ground carbon are complex and vary based on several broad-scale climatic and other factors. A strong longitudinal precipitation gradient is evident in North America, as predominantly west-to-east atmospheric circulation interacts with north-south cordilleras such as the Rocky Mountains. More mesic forested ecosystems to the west of these ranges generally support higher levels of aboveground carbon in terms of tree biomass. Grassland ecosystems can also support high levels of belowground carbon.

**How to interpret the map:** The maps above shows below-ground soil carbon at 1 meter depth `r ifelse(params$html,"(top panel)","(left panel)")` and above-ground carbon stored in tree biomass `r ifelse(params$html,"(bottom panel)","(right panel)")`. Red shades indicate areas with the highest concentrations of carbon per unit area, whereas blue shades indicate areas with low levels of carbon. The spatial data can be downloaded [here](http://globbiomass.org/wp-content/uploads/GB_Maps/Globbiomass_global_dataset.html) and [here](https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/c02ddf8b-cbfb-4533-a9c3-7bf0790fd042).

```{r, results = 'asis', echo = F}
if (params$fmt == "word_document") {
  cat('#####')
}
if (params$RBS){
  shiny::setProgress(0.77)
}
```
```{r,echo=F}
if(params$fmt=="word_document"){
  ow = "13.2cm"
} else if (params$html){
  ow = "100%"
} else{
  ow = "80%"
}
```
## Map of intactness for `r params$poly$Name`
```{r intactness, echo = params$printCode, results = chunktype, out.width=ow, fig.align = 'center',eval=!is.na(params$poly$intact)}
ind<-which(tilelist$tileName=="intact500")
if(isFALSE(params$html)){
  if(file.exists(paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"))
  } else if(!file.exists(paste0(getwd(),"/imgs/intact_",params$poly$Name,".png")) & file.exists(paste0(getwd(),"/tmp/intact_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0(getwd(),"/tmp/intact_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T,
      label= htmlEscape(paste0('Name: ',params$poly$Name))
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "Intactness",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal=cols,
      values=c(0:100),
      title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
      opacity = 0.9,
      labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
    ) %>%
    addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Intactness"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0(getwd(),"/tmp/intact_",params$poly$Name,".html"),
      file=paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0(getwd(),"/imgs/intact_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T,
    label= htmlEscape(paste0('Name: ',params$poly$Name))
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "Intactness",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal=cols,
    values=c(0:100),
    title = paste0("Legend: Quantiles<br>",tilelist$tileGroup[ind]),
    opacity = 0.9,
    labFormat = labelFormat(suffix = "%",transform = function(x) sort(x, decreasing = TRUE))
  ) %>%
  addLayersControl(
      position = c("topleft"),
      baseGroups = c("ESRI Relief","ESRI Terrain","Street Map"),
      overlayGroups = c("Place labels","Intactness"),
      options = layersControlOptions(collapsed = T, autoZIndex = F)
    ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.79)
}
```

**The Human Footprint** - 
The effects of climate stressors on natural systems interact with and can be magnified by other human-caused stressors such as land conversion and development. Human modification of the landscape shows a strong latitudinal gradient in North America, increasing in intensity from the boreal region to mid-latitudes. In much of the boreal region, development corridors are embedded within a more intact matrix. In mid-latitude regions, large protected area complexes and other wild areas appear as islands within a more developed matrix. The intensity of anthropogenic stressors has been termed the **human footprint** or **human modification index** ([Kennedy et al. 2019](https://onlinelibrary.wiley.com/doi/abs/10.1111/gcb.14549)). We represent this metric here as intactness, the inverse of anthropogenic landuse intensity, so that, as with other climate resilience metrics described here, increasing values of the metric correspond to increasing resilience. Global human footprint data such as used here should be interpreted with caution as they will inevitably omit some anthropogenic features captured in region-specific datasets.

**How to interpret the map:** The map above shows intactness (the inverse of human land use intensity). Red shades indicate areas with highest intactness, whereas blue shades indicate areas with lowest intactness (highest levels of development). The spatial data can be downloaded [here](https://figshare.com/articles/Global_Human_Modification/7283087).

```{r, results = 'asis', echo = F}
if (params$fmt == "word_document") {
  cat('#####')
}
if (params$RBS){
  shiny::setProgress(0.85)
}
```

## Climate resilience metric starplot for `r params$poly$Name`
```{r starplot, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'center', eval=T}
if(isTRUE(params$pa)){
  pamin <- l1min[which(l1min$ecr1_id %in% params$poly$ecoreg1),2:9]
  pamin <- pamin %>% summarise_all(min,na.rm=F)
  pamax <- l1max[which(l1max$ecr1_id %in% params$poly$ecoreg1),2:9]
  pamax <- pamax %>% summarise_all(max,na.rm=F)
  pamin$Name <- "MIN"
  pamax$Name <- "MAX"
  names(pamin) <- c('Intactness','Topodiversity','Forward Climatic Refugia','Backward Climatic Refugia','Bird Refugia','Tree Refugia',
                         'Tree Carbon','Soil Carbon',"Name")
  names(pamax) <- c('Intactness','Topodiversity','Forward Climatic Refugia','Backward Climatic Refugia','Bird Refugia','Tree Refugia',
                    'Tree Carbon','Soil Carbon',"Name")
  names(polydata)[3]<-'Topodiversity'
  paminmax <- bind_rows(pamin,pamax) %>% mutate_at(1:8,funs(as.numeric))
  stardata <- bind_rows(paminmax,polydata %>% slice(1:2))
} else {
  edata <- ecos[which(ecos$ecoreg3 == params$poly$ecoreg3),]
  emin <- l3min[which(l3min$ecr3_id == edata$ecoreg3),2:9]
  emax <- l3max[which(l3max$ecr3_id == edata$ecoreg3),2:9]
  emin$NEWNAME <- "MIN"
  emax$NEWNAME <- "MAX"
  names(emin) <- c('Intactness','Topodiversity','Forward Climatic Refugia','Backward Climatic Refugia','Bird Refugia','Tree Refugia',
                         'Tree Carbon','Soil Carbon',"Name")
  names(emax) <- c('Intactness','Topodiversity','Forward Climatic Refugia','Backward Climatic Refugia','Bird Refugia','Tree Refugia',
                    'Tree Carbon','Soil Carbon',"Name")
  names(polydata)[3]<-'Topodiversity'
  eminmax <- bind_rows(emin,emax) %>% mutate_at(1:8,funs(as.numeric))
  stardata <- bind_rows(eminmax,polydata %>% slice(c(1,4)))
}
if(isTRUE(params$html)){
  p<-radarplot(stardata,namecol="Name",interactive=T)
  p
} else {
  if(params$fmt=="word_document"){
    p<-radarplot(stardata,namecol="Name",interactive=F,word=T)
    p
  } else{
    p<-radarplot(stardata,namecol="Name",interactive=F)
    p
  }
}
if (params$RBS){
  shiny::setProgress(0.87)
}
```

**Data visualization** - The wide variety of climate exposure and refugia metrics can seem confusing. However, there are several ways to integrate information from diverse metrics.
As discussed previously, coarse-resolution velocity metrics can be combined with fine-resolution diversity metrics in order to leverage the respective strengths of the two groups of metrics as tools for identification of potential macro-and microrefugia that in combination help maximize both transient and long-term resilience to climate change.
Alternately, planners can integrate multiple climate exposure metrics for an area of interest into a single diagram to produce a composite "fingerprint" representing factors affecting climate resilience.
[Garcia et al. 2014](http://science.sciencemag.org/content/344/6183/1247579) developed the concept of using a starplot to show the varying magnitudes of different climate metrics.
A starplot provides a compact way to communicate contrasts between the intensity of different climate exposure stressors in a region.

**How to interpret the starplot:** The starplot above shows the climate resilience value of `r paste(params$poly$Name)` in terms of eight metrics described above, as compared to that of the ecoregion as a whole. The starplot is scaled relative to the maximum and minimum of the values found within the `r ifelse(isTRUE(params$pa),"Level 1","Level 3")` ecoregion that the `r ifelse(isTRUE(params$pa),"protected area","watershed")` is found in.
For more information on patterns of climate resilience within North American watersheds and management areas, see this app's`r a(href=paste0(params$appURL,'/?_inputs_&tabs="climtourTab"'),strong("Climate Metric Tour"))`and`r a(href=paste0(params$appURL,'/?_inputs_&tabs="patourTab"'),strong("Protected Area Tour"))`tabs. To view and compare maps of climate resilience metrics, see this app's`r tags$a(href=paste0(params$appURL,'/?_inputs_&tabs="climexpTab"'),strong("Climate Resilience Metrics Explorer"))`and`r a(href=paste0(params$appURL,'/?_inputs_&tabs="paexpTab"'),strong("Protected Area Explorer"))`tabs.

```{r, results = 'asis', echo = F}
if (params$fmt == "word_document") {
  cat('#####')
}
if (params$RBS){
  shiny::setProgress(0.94)
}
```

## Climate resilience metric scatterplots for `r params$poly$Name`
```{r scatterplot, echo = params$printCode, results = chunktype, out.width = ow, fig.align = 'center',eval=T}
if(!is.null(params$data2)){
  data<-params$data2
  poly<- params$poly
  if(isTRUE(params$pa)){
    dat2<- data[which(data$ecoreg1 %in% poly$ecoreg1),]
  } else{
    dat2 <- data[which(data$ecoreg3 %in% poly$ecoreg3),]
  }
  dat2<-dat2 %>%st_drop_geometry()
  poly<-poly %>% st_drop_geometry()
}
if(isTRUE(params$pa)){
  nam="PA_NAME"
  
} else {
  nam = "NEWNAME"
  
}
namecol<-"Name"
names(dat2)[which(names(dat2)==nam)]<-"Name"
wd<-params$fmt=="word_document" | (params$fmt=="html_document" & params$html==F)
if(isFALSE(params$html)){
  p1<- xyplot(data=dat2,data2=poly,yvar="fwvelref",xvar="bwvelref",yvarname="Forward Climate Refugia",
              xvarname="Backward Climate Refugia",nam=namecol,offset=0,pa=params$pa,live=F,word=wd)+
    xlab("Backward Climate Refugia")+
    ylab("Forward Climate Refugia")+
    theme(legend.position = "none",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"),aspect.ratio=1)
  p2<- xyplot(data=dat2,data2=poly,yvar="elevdiv",xvar="bwvelref",yvarname="Topodiversity"
              ,xvarname="Backward Climate Refugia",nam="PA_NAME",offset=0,pa=params$pa,live=F,word=wd)+
    xlab("Backward Climate Refugia")+
    ylab("Topographic Diversity")+
    theme(legend.position = "none",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"),aspect.ratio=1)
  if(!is.na(poly$brdref)){
    p3<- xyplot(data=dat2,data2=poly,yvar="brdref",xvar="treref",yvarname="Bird Habitat Refugia",
                xvarname="Tree Habitat Refugia",nam=namecol,offset=0,pa=params$pa,live=F,word=wd)+
      ylab("Bird Habitat Refugia")+
      xlab("Tree Habitat Refugia")+
      theme(legend.position = "none",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"),aspect.ratio=1)
  } else {
    p3<- xyplot(data=dat2,data2=poly,yvar="intact",xvar="bwvelref",yvarname="Landscape Intactness",
                xvarname="Backward Climate Refugia",nam=namecol,offset=0,pa=params$pa,live=F,word=wd)+
      ylab("Landscape Intactness")+
      xlab("Backward Climate Refugia")+
      theme(legend.position = "none",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"),aspect.ratio=1)
  }
  p4<- xyplot(data=dat2,data2=poly,yvar="treec",xvar="soilc",yvarname="Tree Carbon Content",
              xvarname="Soil Carbon Content",nam=namecol,offset=0,pa=params$pa,live=F,word=wd)+
    ylab("Tree Carbon Content")+
    xlab("Soil Carbon Content")+
    theme(legend.position = "none",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"),aspect.ratio=1)
  
  legend <- get_legend(
    p1 +
      guides(color = guide_legend(nrow = 1)) +
      theme(legend.position = "bottom",axis.text=element_text(size=8),
            axis.title=element_text(size=8,face="bold"))
  )
  p<-plot_grid(p1,p2,p3,p4,labels="AUTO")
  p<-plot_grid(p,legend,nrow=2,ncol=1,rel_heights = c(1, .1))
  if(params$fmt=="word_document"){
    p<-plot_grid(p1,p2,p3,p4,labels="AUTO",label_size=8)
    p<-plot_grid(p,legend,nrow=2,ncol=1,rel_heights = c(1, .1),label_size=8)
  } else{
    p<-plot_grid(p1,p2,p3,p4,labels="AUTO")
    p<-plot_grid(p,legend,nrow=2,ncol=1,rel_heights = c(1, .1))
  }
  p
} else {
  ggplotColours <- function(n = nrow(data2), h = c(0, 360)+15) {
    if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
    hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
  }
  offset=0
  col2 <- ggplotColours(n=(nrow(poly)+offset))[(1+offset):(offset+nrow(poly))]
  if(isFALSE(pa)){
      dat2$Group<-" Surrounding Ecoregion "
      
    } else {
      dat2$Group<-" Surrounding Biome(s) "
    }
  poly$Group <- poly$Name
  
  data <- bind_rows(dat2,poly)
  fig <- plot_ly(width="100%")
  fig1 <- fig %>% add_markers(
    data = data, x = ~bwvelref,y = ~fwvelref ,color = ~Group, 
    colors=c("grey",col2),legendgroup=~Group,showlegend=F,
    text = ~I(Name),
    hovertemplate = paste(
      '<b>Name</b>: %{text}<br>',
      '<b>Forward Climate Refugia</b>: %{y:.3f}}<br>',
      '<b>Backward Climate Refugia</b>: %{x:.3f}<br>'
    )
  ) %>%
    plotly::layout(
      xaxis = list(
        title = "Backward Climate Refugia",
        standoff=0,
        automargin=F
      ),
      yaxis = list(
        title = "Forward Climate Refugia"
      ),
      margin=list(b=0)
    )
  fig2 <- fig %>% add_markers(
    data=data,x= ~bwvelref,y= ~elevdiv,color= ~Group,
    colors=c("grey",col2),legendgroup=~Group,showlegend=F,
    text = ~I(Name),
    hovertemplate = paste(
      '<b>Name</b>: %{text}<br>',
      '<b>Togographic Diversity</b>: %{y:.3f}}<br>',
      '<b>Backward Climate Refugia</b>: %{x:.3f}<br>'
    )
  ) %>%
    plotly::layout(
      xaxis = list(
        title = "Backward Climate Refugia",
        standoff=0,
        automargin=F
      ),
      yaxis = list(
        title = "Togographic Diversity"
      ),
      margin=list(b=0)
    )
  if(!is.na(poly$brdref)){
    fig3 <- fig %>% add_markers(
      data=data,x= ~treref,y= ~brdref,color= ~Group,
      colors=c("grey",col2),legendgroup=~Group,showlegend=F,
      text = ~I(Name),
      hovertemplate = paste(
        '<b>Name</b>: %{text}<br>',
        '<b>Bird Refugia</b>: %{y:.3f}}<br>',
        '<b>Tree Refugia</b>: %{x:.3f}<br>'
      )
    ) %>%
      plotly::layout(
        xaxis = list(
          title = "Tree Refugia",
          standoff=0,
          automargin=F
        ),
        yaxis = list(
          title = "Bird Refugia"
        ),
      margin=list(b=0)
      )
  } else {
    fig3 <- fig %>% add_markers(
      data=data,x= ~bwvelref,y= ~intact,color= ~Group,
      colors=c("grey",col2),legendgroup=~Group,showlegend=F,
      text = ~I(Name),
      hovertemplate = paste(
        '<b>Name</b>: %{text}<br>',
        '<b>Intactness</b>: %{y:.3f}}<br>',
        '<b>Backward Climate Refugia</b>: %{x:.3f}<br>'
      )
    ) %>%
      plotly::layout(
        xaxis = list(
          title = "Backward Climate Refugia",
          standoff=0,
        automargin=F
        ),
        yaxis = list(
          title = "Intactness"
        ),
        margin=list(b=0)
      )
  }
  fig4 <- fig %>% add_markers(
    data=data,x= ~soilc,y= ~treec,color= ~Group,
    colors=c("grey",col2),legendgroup=~Group,
    text = ~I(Name),
    hovertemplate = paste(
      '<b>Name</b>: %{text}<br>',
      '<b>Soil Carbon</b>: %{y:.3f}}<br>',
      '<b>Tree Carbon</b>: %{x:.3f}<br>'
    )
  ) %>%
    plotly::layout(
      xaxis = list(
        title = "Tree Carbon",
        standoff=0,
        automargin=F
      ),
      yaxis = list(
        title = "Soil Carbon"
      ),
      margin=list(b=0)
    )
  f <- subplot(fig1, fig2,fig3, fig4,nrows=2,titleX=T,titleY=T,margin=c(0.08,0.08,0.08,0.08)) %>% 
    plotly::layout(legend = list(orientation = 'h',x = 0, y = -0.15,yanchor="top"))
  f
}
if (params$RBS){
  shiny::setProgress(0.96,message="Stitching the final content together...")
}
```

**Scatterplots** - This page shows several x-y scatterplots for `r paste(params$poly$Name)`. Each plot shows values for `r paste(params$poly$Name)` for two metrics, in the context of values shown in the biome as a whole. Gray points show values for all `r ifelse(isTRUE(params$pa),"protected areas","watersheds")` falling within the corresponding `r ifelse(isTRUE(params$pa),"L1 ecoregion","L3 Ecoregion")`. To create and compare custom scatterplots of climate resilience metrics, see this app's`r a(href=paste0(params$appURL,'/?_inputs_&tabs="climexpTab"'),strong("Climate Resilience Metrics Explorer"))`and`r a(href=paste0(params$appURL,'/?_inputs_&tabs="paexpTab"'),strong("Protected Area Explorer"))`tabs.


