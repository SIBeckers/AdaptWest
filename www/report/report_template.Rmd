---
title: 'Climate Resilience Metric Report'
params:
   poly: NULL
   table: TRUE
   vdata: TRUE
   starplot: TRUE
   scatterplot: TRUE
   l1data: TRUE
   l2data: TRUE
   l3data: TRUE
   printCode: FALSE 
   html: FALSE #Interactive HTML?
   RBS: TRUE # Report progress?
always_allow_html: true
output:
  md_document: default
  powerpoint_presentation: default
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
urlcolor: blue
sansfont: Calibri    
---

```{r SETUP, include=FALSE}
# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = params$printCode,message = FALSE, warning = FALSE,
                      fig.height = 8, fig.width = 8, error = F,tidy = T, out.width = "100%",
                      fig.align = "center", strip.white = T,cache = F)
source("./mapFunction.R")

LeafletSideBySidePlugin <- htmlDependency("leaflet-side-by-side","2.0.0",
                                          src = c("../js/leaflet-side-by-side-gh-pages"),
                                          script = "leaflet-side-by-side.js")
registerPlugin <- function(mapFunction, plugin) {
  mapFunction$dependencies <- c(mapFunction$dependencies, list(plugin))
  mapFunction
}
# source("../code/radarplot.R")
# source("../code/xyplot.R")
if(!dir.exists("./tmp")){dir.create("./tmp")}
if(!dir.exists("./imgs")){dir.create("./imgs")}
print(params$p)
bds <- st_bbox(params$poly)
bds <- unname(bds)

fullmap<-mapFunction()
halfmap<-mapFunction(width="50%")
fullhalfmap<-mapFunction(height="400px")
if(isTRUE(params$html)) {
  chunktype = "hold"
} else {
  chunktype = "asis"
}
if(isTRUE(params$RBS)){
  shiny::setProgress(0.04)
}
```

### Climate Resilience Metric Report for `r params$poly$Name`

This report has been generated by the AdaptWest Climate Resilience
web-application at <center><h4>
[https://adaptwest.shinyapps.io/climate_displacement](https://adaptwest.shinyapps.io/climate_displacement)
</h4></center>
This report contains the data tables and figures for `r paste(params$poly$Name)`. 
Additionally, you can download the climate data for your protected area from 
within the app.
Additional features and capabilities may be developed and the format of this 
report and the application layout may change.
### Organizations participating in or supporting development of the application:
AdaptWest, Canadian Forest Service

## Introduction
Conservation planners and practitioners increasingly wonder how they should revise conservation strategies in the face of the unprecedented threat to biodiversity from climate change. One key step is to consider the relatively consistent spatial patterns that characterize the "geography of climate exposure and resilience". These patterns are often generated by the interaction of global climate systems with regional topography, but may also be influenced by biogeographic processes and other factors. A qualitative understanding of these patterns can help planners craft conservation strategies that are more resilient to uncertainty regarding the future intensity of climate change.

The ultimate goal of landscape-level conservation planning under climate change is to facilitate persistence of species and ecosystem processes by increasing the adaptive capacity of landscapes and regions. The **ESAC** framework, developed by the IPCC [(McCarthy et al. 2001)](https://www.ipcc.ch/ipccreports/tar/wg2/pdf/wg2TARfrontmatter.pdf), proposes that climate Exposure and Sensitivity interact and are mediated by Adaptive Capacity, resulting in the degree of vulnerability of the system to climate change.

Most of the data considered here are measures of climate **exposure**. Data, such as the location of climate refugia for individual species, which incorporates information on a species' climatic tolerances or niche, also addresses climate **sensitivity**. The ultimate goal of providing such information to planners is to support conservation management that, by protecting key areas identified by the data, increases the **adaptive capacity** of the landscape and its ability to support native species and ecosystems into the future.

A diversity of conservation strategies is needed to address climate change adaptation challenges. Among the most important are identification and protection of climate refugia (areas buffered from climate change where organisms can persist) and climate corridors (areas that play a key role in facilitating
dispersal under climate change).

For further information and citation refer to: 
<blockquote>Carroll, C. & Noss, R. F. (2020) Rewilding in the face of climate change. Conservation Biology in press. [doi: 10.1111/gcb.13663](http://dx.doi.org/[doi]).



<p style="page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.11)
}
```

In this report, we present data for `r paste(params$park)` on key metrics that can be used to assess landscape-level climate resilience and vulnerability. Spatial data shown in this report are freely available at the links below.

  **Climate Resilience Metric:**
  
  * [Forward and backward climatic velocity](https://adaptwest.databasin.org/pages/adaptwest-velocitywna)
  * [Topodiversity](https://adaptwest.databasin.org/pages/environmental-diversity-north-america)
  * [Biotic velocity](https://adaptwest.databasin.org/pages/climatic-macrorefugia-for-trees-and-songbirds)
  * [Climate connectivity](https://adaptwest.databasin.org/pages/climate-connectivity-north-america)
  * [Aboveground forest carbon](http://globbiomass.org/wp-content/uploads/GB_Maps/Globbiomass_global_dataset.html)
  * [Soil carbon](https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/c02ddf8b-cbfb-4533-a9c3-7bf0790fd042)
  * [Intactness (the inverse of landuse intensity)](https://figshare.com/articles/Global_Human_Modification/7283087)

## Basic Information for `r params$poly$Name`
```{r REFUGIA_TABLE, echo = params$printCode, results = 'asis',eval = params$table}
polydata <-params$poly %>%st_drop_geometry() %>% select(Name,intact,elevdiv,fwvelref,bwvelref,brdref,treref,treec,soilc) %>%
  mutate_at(.vars=vars(brdref,treref,treec),funs(as.numeric))

if(isTRUE(params$l1data)) {
  l1data<-ecol1stats[which(ecol1stats$Name==params$poly$ecoreg1),]
  # l1data[,1]<-as.character(l1data[,1])
  l1data[1,1]<-paste0("L1_EcoRegion_",l1data[1,1])
  # names(l1data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l1data,use.names=F)
}

if(isTRUE(params$l2data)) {
  l2data<-ecol2stats[which(ecol2stats$Name==params$poly$ecoreg2),]
  # l2data[[namecol]]<-as.character(l2data[,1])
  l2data[1,1]<-paste0("L2_EcoRegion_",l2data[1,1])
  # names(l2data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l2data,use.names=F)
}


if(isTRUE(params$l3data)) {
  l3data<-ecol3stats[which(ecol3stats$Name==params$poly$ecoreg3),]
  # l3data[,1]<-as.character(l3data[,1])
  l3data[1,1]<-paste0("L3_EcoRegion_",l3data[1,1])
  # names(l3data)[1]<-"Name"
  # names(polydata)[1]<-"Name"
  polydata<-rbind(polydata,l3data,use.names=F)
}

names(polydata)<-names(paminmax)[c(9,1:8)]
polydata<-setDF(polydata)

knitr::kable(
  polydata,
  row.names=F,
  caption= paste0("Adaptation Metrics for: ", params$poly$Name)
)
if (params$RBS){
  shiny::setProgress(0.15)
}
```




```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.23)
}
```

## Map of forwards climate refugia for `r params$poly$Name`
```{r fwdvel, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="fwvel500")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/fwsvel_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0("./imgs/fwsvel_",params$poly$Name,".png"))
  } else if(!file.exists(paste0("./imgs/fwsvel_",params$poly$Name,".png")) & file.exists(paste0("./tmp/fwsvel_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/fwsvel_",params$poly$Name,".html"),
      file=paste0("./imgs/fwsvel_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0("./imgs/fwsvel_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% 
      clearGroup("metrics") %>% 
      addPolygons(
        data = params$poly,
        fillColor = NULL,
        fillOpacity = 0.00,
        weight = 5,
        color = "black",
        stroke = T
      ) %>% 
      addTiles(
        urlTemplate = tilelist$tileSubdir[ind],
        attribution = tilelist$tileAttribution[ind],
        group = "metrics",
        options = tileOptions(
          tms = T,
          minZoom = minZoom,
          maxZoom = maxZoom,
          unloadInvisibleTiles = T,
          noWrap = T,
          opacity = 0.9,
          zIndex = 9000
        )
      ) %>%
      fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
      mapview::mapshot(
        x= m,
        url = paste0("./tmp/fwsvel_",params$poly$Name,".html"),
        file=paste0("./imgs/fwsvel_",params$poly$Name,".png"),
        remove_url=F,
        selfcontained=T
      )
    knitr::include_graphics(paste0("./imgs/fwsvel_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% 
    clearGroup("metrics") %>%
    addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% 
    addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.28)
}
```
<br>
<br>
**Climate velocity** is the speed that an organism needs to travel to keep pace with climate. Climate refugia (areas of species persistence during climate change) are areas of low enough velocity that the organism can remain within their suitable climate.

To calculate analog-based climatic velocity, climate is categorized into types, and the straight-line distance is measured between a site and the nearest site with the same climate type in a different time period. Climatic velocity is influenced by processes 
at several scales: 

* Local topography 
* Regional topographic position 
* Location on continent
* Location in relationship to global climate circulation patterns

**Forward climatic velocity** measures the straight-line distance between a site's current climate type and the nearest site with the same climate type under future climates. This represents the rate at which an organism currently at a location must move to find future suitable climate.  

The map above shows refugia based on forward climatic velocity from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5).
<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.34)
}
```
## Map of backwards climate refugia for `r params$poly$Name`
```{r bwdvel, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="bwvel500")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/bwsvel_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0("./imgs/bwsvel_",params$poly$Name,".png"))
  } else if(!file.exists(paste0("./imgs/bwsvel_",params$poly$Name,".png")) & file.exists(paste0("./tmp/bwsvel_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/bwsvel_",params$poly$Name,".html"),
      file=paste0("./imgs/bwsvel_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0("./imgs/bwsvel_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/bwsvel_",params$poly$Name,".html"),
      file=paste0("./imgs/bwsvel_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0("./imgs/bwsvel_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.36)
}
```
**Backward climatic velocity** measures the straight-line distance between a site's future climate type and the nearest site with the same climate type under current climates. This represents the rate at which organisms adapted to a location's future climate will need to move to colonize that location. 
Backward velocity represents the distance and rate at which organisms adapted to a location's future climate will need to move to reach that location, and reflects a location's ability to serve as a refugium for species and ecosystems. 
Backward velocity is generally low in alpine areas, because adapted organisms can reach the site from nearby downslope locations. Values are often high in valley bottom habitat because organisms must travel longer distances to colonize these locally new habitat conditions.

Areas with low backward climatic velocity will have higher values as refugia, so we transform velocity values to a refugia index by multiplying the log transformation of velocity by negative 1. A log transformation is used because we are most interested in variation in the index at relatively low velocity values. 

The map above shows refugia based on backward climatic velocity from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5).
<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.40)
}
```

## Map of Microrefugia Potential for `r params$poly$Name`
```{r Topodiversity, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="elevdiv500")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/elevdiv_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0("./imgs/elevdiv_",params$poly$Name,".png"))
  } else if(!file.exists(paste0("./imgs/elevdiv_",params$poly$Name,".png")) & file.exists(paste0("./tmp/elevdiv_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/elevdiv_",params$poly$Name,".html"),
      file=paste0("./imgs/elevdiv_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0("./imgs/elevdiv_",params$poly$Name,".png"))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/elevdiv_",params$poly$Name,".html"),
      file=paste0("./imgs/elevdiv_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0("./imgs/elevdiv_",params$poly$Name,".png"))
  }
} else {
  m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.45)
}
```
<br>
**Microrefugia potential**
 - Many approaches to identifying areas that will be refuges for biodiversity under climate change are based on predicting future climate. Other approaches use only information on the current environment. Species distributions, communities, ecosystems, and broader patterns of biodiversity are known to be influenced by abiotic drivers such as soils, geology, and topography.
Refugia also span a range of spatial scales. Coarse-resolution metrics such as climatic velocity which identify **macrorefugia** (areas where broad-scale climate is relatively stable and suitable for persistence) can be complemented with other information that helps identify fine-scale **microrefugia** (small areas with locally favorable environments within otherwise unsuitable climates).  
Micro-scale climate refugia can be created by terrain-related factors, as shown in the figure below from [Morelli et al. (2016).](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0159909)
Topographic diversity (topodiversity) data are useful for identifying areas where a heterogeneous physical environment (e.g., steep elevation gradients or diverse aspects) increases the likelihood that species will be able to find nearby suitable habitat as climate changes.  
Microrefugia occur both within and outside of macro-refugia (areas of lowest climate velocity).    
The map above shows topographic diversity. The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/environmental-diversity-north-america). 

<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.49)
}
```
## Map of Biotic Velocity for `r params$poly$Name`
```{r biotic_velocity, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'default',eval=T}
ind<-which(tilelist$tileName=="birdref500")
ind2<-which(tilelist$tileName=="treeref500")

if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/birdref_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0("./imgs/birdref_",params$poly$Name,".png"),paste0("./imgs/treeref_",params$poly$Name,".png")))
  } else if(!file.exists(paste0("./imgs/birdref_",params$poly$Name,".png")) & file.exists(paste0("./tmp/birdref_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/birdref_",params$poly$Name,".html"),
      file=paste0("./imgs/birdref_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0("./tmp/treeref_",params$poly$Name,".html"),
      file=paste0("./imgs/treeref_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0("./imgs/birdref_",params$poly$Name,".png"),paste0("./imgs/treeref_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/birdref_",params$poly$Name,".html"),
      file=paste0("./imgs/birdref_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/treeref_",params$poly$Name,".html"),
      file=paste0("./imgs/treeref_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0("./imgs/birdref_",params$poly$Name,".png"),paste0("./imgs/treeref_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.53)
}
```

**Biotic velocity** is a metric that combines data from climate projections with data on the distributions of individual species. Climatic niche models based on correlations between species distributions and current climatic conditions are then projected forward to predict distribution under future climates. Biotic velocity represents the distance between a site and the nearest site projected to be climatically suitable for the species under future projected climates.  
Biotic velocities provide a lower estimate of migration requirements than does climatic velocity because the metric assumes local populations can adapt to any climatic conditions found within the full range of the species current distribution. The metric can be reported on a per-species basis or averaged across a taxa group.
Backward biotic velocity provides a  species-specific refugia index.
When compared to refugia defined by low climatic velocity, biotic velocity highlights the influence of biogeographic factors (including past refugia locations) which have made certain regions, such as California and the southern Appalachians, more biodiverse than expected based on climate alone. 
Biotic-velocity-based refugia vary depending on the species considered. Stralberg et al. 2018 mapped refugia for 592 songbird and tree species.
The map above shows refugia based on climatic niche models for songbirds (top panel) and trees (bottom panel). The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/climatic-macrorefugia-for-trees-and-songbirds).

<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.60)
}
```
## Map of Climate Connectivity for `r params$poly$Name`
```{r climate_connectivity, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="fwshpath")
ind2<-which(tilelist$tileName=="bwshpath")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/fwshpath_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0("./imgs/fwshpath_",params$poly$Name,".png"),paste0("./imgs/bwshpath_",params$poly$Name,".png")))
  } else if(!file.exists(paste0("./imgs/fwshpath_",params$poly$Name,".png")) & file.exists(paste0("./tmp/fwshpath_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/fwshpath_",params$poly$Name,".html"),
      file=paste0("./imgs/fwshpath_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0("./tmp/bwshpath_",params$poly$Name,".html"),
      file=paste0("./imgs/bwshpath_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0("./imgs/fwshpath_",params$poly$Name,".png"),paste0("./imgs/bwshpath_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/fwshpath_",params$poly$Name,".html"),
      file=paste0("./imgs/fwshpath_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/bwshpath_",params$poly$Name,".html"),
      file=paste0("./imgs/bwshpath_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0("./imgs/fwshpath_",params$poly$Name,".png"),paste0("./imgs/bwshpath_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.62)
}
```
<!-- ![Forwards Shortest Path Climate Connectivity Map](./fwshpath.png){width="50%"}![Backwards Shortest Path Climate Connectivity Map](./bwshpath.png){width="50%"} -->


**Climate connectivity** - The persistence of many species under climate change will depend areas that facilitate dispersal to newly climatically suitable habitat. **Climate connectivity areas** or "climate corridors" are areas that form the best route between current climate types and where those climates will occur in the future under climate change. Climate connectivity areas are distinct from refugia and thus poorly captured by many existing conservation strategies. Because dispersing organisms may need to avoid hostile climates, these routes are often circuitous rather than the straight-line paths, as is assumed when measuring standard climatic velocity [Dobrowski and Parks 2016](https://www.nature.com/articles/ncomms12349). Several methods exist for identifying climate corridors. [Carroll et al. 2018](https://onlinelibrary.wiley.com/doi/full/10.1111/gcb.14373) used centrality metrics to identify areas where many potential dispersal paths overlap.
Broad-scale topography and climate influence connectivity paths. Routes were found to be funneled along north-south trending passes and valley systems and along the leeward or drier slopes of north-south trending mountain ranges. Climate connectivity paths also tend to avoid areas of novel and disappearing climates. Human landuses may further constrain the ability of species to disperse through these areas.
The map above shows forward (left panel) and backward (right panel) climatic connectivity areas from current to 2080s climate for a "business-as-usual" emissions scenario (RCP8.5). The spatial data can be downloaded [here](https://adaptwest.databasin.org/pages/climate-connectivity-north-america).

<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.68)
}
```
## Map of Above- and Below-Ground Carbon for `r params$poly$Name`
```{r carbon, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="soilc500")
ind2<-which(tilelist$tileName=="treena500")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/soilc_",params$poly$Name,".png"))){
    knitr::include_graphics(c(paste0("./imgs/soilc_",params$poly$Name,".png"),paste0("./imgs/treec_",params$poly$Name,".png")))
  } else if(!file.exists(paste0("./imgs/soilc_",params$poly$Name,".png")) & file.exists(paste0("./tmp/soilc_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/soilc_",params$poly$Name,".html"),
      file=paste0("./imgs/soilc_",params$poly$Name,".png"),
    )
    webshot::webshot(
      url = paste0("./tmp/treec_",params$poly$Name,".html"),
      file=paste0("./imgs/treec_",params$poly$Name,".png"),
    )
    knitr::include_graphics(c(paste0("./imgs/soilc_",params$poly$Name,".png"),paste0("./imgs/treec_",params$poly$Name,".png")))
  } else {
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/soilc_",params$poly$Name,".html"),
      file=paste0("./imgs/soilc_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    m <- fullmap %>% clearGroup("metrics") %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind2],
      attribution = tilelist$tileAttribution[ind2],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/treec_",params$poly$Name,".html"),
      file=paste0("./imgs/treec_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(c(paste0("./imgs/soilc_",params$poly$Name,".png"),paste0("./imgs/treec_",params$poly$Name,".png")))
  }
} else {
  m <- fullhalfmap %>% clearGroup("metrics") %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  
  m2 <- fullhalfmap %>% clearGroup("metrics")%>% clearGroup("metrics") %>%
  addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind2],
    attribution = tilelist$tileAttribution[ind2],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  p(m,m2)
}
if (params$RBS){
  shiny::setProgress(0.7)
}
```

**Above- and below-ground carbon** - Climate adaptation planning addresses the impacts of climate change via efforts to increase landscape resilience and other strategies. However, it is important to place climate adaptation strategies within a larger context which includes mitigation strategies to address the causes of climate change by reducing accumulation of greenhouse gases in the atmosphere. An example of such a dual adaptation/mitigation strategy is a recent conservation proposal termed the Global Deal for Nature, which proposes that protected area networks be expanded to include areas that hold large reserves of **aboveground (biomass) and belowground (soil and biomass) carbon**, with the aim of reducing disturbances that accelerate release of stored carbon ([Dinerstein et al. 2019](http://doi.org/10.1126/sciadv.aaw2869)). In North America, soil carbon is generally at highest levels in large boreal peatlands, implying that protection of large boreal landscapes is critical for conserving areas of high soil carbon. Patterns of above-ground carbon are complex and vary based on several broad-scale climatic and other factors. A strong longitudinal precipitation gradient is evident in North America, as predominantly west-to-east atmospheric circulation interacts with north-south cordilleras such as the Rocky Mountains. More mesic forested ecosystems to the west of these ranges generally support higher levels of aboveground carbon in terms of tree biomass. Grassland ecosystems can also support high levels of belowground carbon.
The map above shows above-ground carbon stored in tree biomass (left panel) and below-ground soil carbon (right panel). The spatial data can be downloaded [here](http://globbiomass.org/wp-content/uploads/GB_Maps/Globbiomass_global_dataset.html) and [here](https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/c02ddf8b-cbfb-4533-a9c3-7bf0790fd042).

<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.77)
}
```
## Map of Intactness for `r params$poly$Name`
```{r intactness, echo = params$printCode, results = chunktype, out.width = '100%', fig.align = 'center',eval=T}
ind<-which(tilelist$tileName=="intact500")
if(isFALSE(params$html)){
  if(file.exists(paste0("./imgs/intact_",params$poly$Name,".png"))){
    knitr::include_graphics(paste0("./imgs/intact_",params$poly$Name,".png"))
  } else if(!file.exists(paste0("./imgs/intact_",params$poly$Name,".png")) & file.exists(paste0("./tmp/intact_",params$poly$Name,".html"))) {
    webshot::webshot(
      url = paste0("./tmp/intact_",params$poly$Name,".html"),
      file=paste0("./imgs/intact_",params$poly$Name,".png"),
    )
    knitr::include_graphics(paste0("./imgs/intact_",params$poly$Name,".png"))
  } else {
    m <- m %>% addPolygons(
      data = params$poly,
      fillColor = NULL,
      fillOpacity = 0.00,
      weight = 5,
      color = "black",
      stroke = T
    ) %>% addTiles(
      urlTemplate = tilelist$tileSubdir[ind],
      attribution = tilelist$tileAttribution[ind],
      group = "metrics",
      options = tileOptions(
        tms = T,
        minZoom = minZoom,
        maxZoom = maxZoom,
        unloadInvisibleTiles = T,
        noWrap = T,
        opacity = 0.9,
        zIndex = 9000
      )
    ) %>%
    fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
    mapview::mapshot(
      x= m,
      url = paste0("./tmp/intact_",params$poly$Name,".html"),
      file=paste0("./imgs/intact_",params$poly$Name,".png"),
      remove_url=F,
      selfcontained=T
    )
    knitr::include_graphics(paste0("./imgs/intact_",params$poly$Name,".png"))
  }
} else {
  m <- m %>% addPolygons(
    data = params$poly,
    fillColor = NULL,
    fillOpacity = 0.00,
    weight = 5,
    color = "black",
    stroke = T
  ) %>% 
  addTiles(
    urlTemplate = tilelist$tileSubdir[ind],
    attribution = tilelist$tileAttribution[ind],
    group = "metrics",
    options = tileOptions(
      tms = T,
      minZoom = minZoom,
      maxZoom = maxZoom,
      unloadInvisibleTiles = T,
      noWrap = T,
      opacity = 0.9,
      zIndex = 9000
    )
  ) %>%
  fitBounds(lng1 = bds[1],lat1 = bds[2],lng2 = bds[3],lat2 = bds[4])
  m
}
if (params$RBS){
  shiny::setProgress(0.79)
}
```

**The Human Footprint** - 
The effects of climate stressors on natural systems interact with and can be magnified by other human-caused stressors such as land conversion and development. Human modification of the landscape shows a strong latitudinal gradient in North America, increasing in intensity from the boreal region to mid-latitudes. In much of the boreal region, development corridors are embedded within a more intact matrix. In mid-latitude regions, large protected area complexes and other wild areas appear as islands within a more developed matrix. The intensity of anthropogenic stressors has been termed the **human footprint** or **human modification index** ([Kennedy et al. 2019](https://onlinelibrary.wiley.com/doi/abs/10.1111/gcb.14549)). We represent this metric here as intactness, the inverse of anthropogenic landuse intensity, so that, as with other climate resilience metrics described here, increasing values of the metric correspond to increasing resilience.  The figure below shows the specific data used by [Kennedy et al. 2019](https://onlinelibrary.wiley.com/doi/abs/10.1111/gcb.14549) to produce a composite human modification index.
The map above shows intactness (the inverse of human land use intensity). The spatial data can be downloaded [here](https://figshare.com/articles/Global_Human_Modification/7283087).


<p style = "page-break-before: always">
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
  cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.85)
}
```

## Climate Resilience Metric Star Plot for `r params$poly$Name`
```{r starplot, echo = params$printCode, results = chunktype, out.width = '70%', fig.align = 'center', eval=params$starplot}
# if(isTRUE(params$html)){
#   p<-radarplot(polydata,namecol="Name")
#   p
# } else {
  p<-radarplot(polydata,namecol="Name",interactive=F)
  p
# }
if (params$RBS){
  shiny::setProgress(0.87)
}
```

**Data visualization** - The wide variety of climate exposure and refugia metrics can seem confusing. However, there are several ways to integrate information from diverse metrics.
As discussed previously, coarse-resolution velocity metrics can be combined with fine-resolution diversity metrics in order to leverage the respective strengths of the two groups of metrics as tools for identification of potential macro-and microrefugia that in combination help maximize both transient and long-term resilience to climate change.
Alternately, planners can integrate multiple climate exposure metrics for an area of interest into a single diagram to produce a composite "fingerprint" representing factors affecting climate resilience.
[Garcia et al. 2014](http://science.sciencemag.org/content/344/6183/1247579) developed the concept of using a star plot to show the varying magnitudes of different climate metrics.
A star plot provides a compact way to communicate contrasts between the intensity of different climate exposure stressors in a region.
<br>
<br>
The figure above compares starplot patterns for 9 major protected area complexes within the Yellowstone-to-Yukon (Y2Y) region. The contrast in starplot patterns between southern (e.g., Yellowstone) and northern (e.g., Nahanni) protected areas within Y2Y reflects the long-noted dichotomy between centers of species diversity (hotspots) and wild landscapes (coldspots). Northern protected areas within Y2Y score highly in intactness and protection of soil carbon, whereas southerly protected areas play a greater role in providing macrorefugia as defined by both species models and climatic velocity.
For more information on patterns of climate resilience within North American protected areas, see this app's **Protected Area Tour** tab. To view and compare maps of climate resilience metrics, see this app's **Climate Resilience Metrics Explorer** and **Protected Area Explorer** tabs.

<!-- <p style = "page-break-before: always"> -->
```{r, results = 'asis', echo = F}
fmt <- rmarkdown::default_output_format(knitr::current_input())$name
if (fmt == "pdf_document") {
cat('\\pagebreak')
}
if (params$RBS){
  shiny::setProgress(0.94)
}
```
## Climate Resilience Metric Scatterplots for `r params$poly$Name`
```{r scatterplot, echo = params$printCode, results = chunktype, out.width = '70%', fig.align = 'center',eval=F}
knitr::include_graphics(params$scatterplot)
if (params$RBS){
  shiny::setProgress(0.96)
}
```

**Minimal descriptive text** - To create and compare scatterplots of climate resilience metrics, see this app's **Climate Resilience Metrics Explorer** and **Protected Area Explorer** tabs.

<!-- <p style = "page-break-before: always"> -->
```{r, results = 'asis', echo = F}
# fmt <- rmarkdown::default_output_format(knitr::current_input())$name
# if (fmt == "pdf_document") {
  # cat('\\pagebreak')
# }
```

